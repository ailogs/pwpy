#! /usr/bin/env python
# -*- python -*-
# Copyright 2012 Peter Williams
# Licensed under the GNU General Public License version 3 or higher

"""
sfextract <input image> <SFIND keywords=,+options>

Given an image, run MIRIAD SFIND on it and print *deconvolved* source
parameters on standard output. Options on the command line are passed
through to SFIND more-or-less verbatim.

Note that SFIND expects there to be restoring beam information in the
image; if this is missing, it will make a dumb guess.

Suggested sfind keywords: rmsbox=64 alpha=0.5 +fdrpeak
"""

# Programmer notes:
"""
Not very happy with the deconvolution of (near-)pointlike
sources. I've hacked up the code from gaupar.for which I feel may be
ill-advised. (See astutil.)
"""

import sys, numpy as np
import astimage
from astutil import *
import flatdb, srctable

try:
    from scipy.special import erfinv as ss_erfinv
except ImportError:
    ss_erfinv = None

## quickutil: usage
#- snippet: usage.py (2012 Mar 28)
#- SHA1: 496e3e02df4b92f0d5c8887446e0cdb7fd5dcb10

def showusage (docstring, short, stream, exitcode):
    if stream is None:
        from sys import stdout as stream
    if not short:
        print >>stream, 'Usage:', docstring.strip ()
    else:
        intext = False
        for l in docstring.splitlines ():
            if intext:
                if not len (l):
                    break
                print >>stream, l
            elif len (l):
                intext = True
                print >>stream, 'Usage:', l
        print >>stream, \
            '\nRun with a sole argument --help for more detailed usage information.'
    raise SystemExit (exitcode)

def checkusage (docstring, argv=None, usageifnoargs=False):
    if argv is None:
        from sys import argv
    if len (argv) == 1 and usageifnoargs:
        showusage (docstring, True, None, 0)
    if len (argv) == 2 and argv[1] in ('-h', '--help'):
        showusage (docstring, False, None, 0)

def wrongusage (docstring, *rest):
    import sys
    intext = False

    if len (rest) == 0:
        detail = 'invalid command-line arguments'
    elif len (rest) == 1:
        detail = rest[0]
    else:
        detail = rest[0] % tuple (rest[1:])

    print >>sys.stderr, 'error:', detail, '\n' # extra NL
    showusage (docstring, True, sys.stderr, 1)
## end


def cmdline (argv):
    inpath = None
    keywords = {}

    checkusage (__doc__, argv, usageifnoargs=True)

    for arg in argv[1:]:
        if '=' in arg:
            kw, val = arg.split ('=', 1)
            keywords[kw] = val
        elif arg[0] == '+':
            for opt in arg[1:].split (','):
                keywords[opt] = True
        elif inpath is not None:
            wrongusage (__doc__, 'only one non-keyword argument is allowed')
        else:
            inpath = arg

    if inpath is None:
        wrongusage (__doc__, 'must supply input image path')
    if 'logfile' in keywords:
        del keywords['logfile']
        warn ('the "logfile" parameter to sfind will be ignored')
    if keywords.get ('fdrimg', False):
        warn ('the file created by the "fdrimg" option will be discarded')
    if keywords.get ('sigmaimg', False):
        warn ('the file created by the "sigmaimg" option will be discarded')
    if keywords.get ('rmsimg', False):
        warn ('the file created by the "rmsimg" option will be discarded')
    if keywords.get ('normimg', False):
        warn ('the file created by the "normimg" option will be discarded')
    if keywords.get ('kvannot', False):
        warn ('the file created by the "kvannot" option will be discarded')

    sfind_extract (inpath, keywords)


def sfind_extract (inpath, keywords):
    img = astimage.open (inpath, 'r')
    sfinfo = {'imagepath': inpath,
              'sfindargs': ' '.join ('%s=%s' % (k, keywords[k])
                                     for k in sorted (keywords.iterkeys ()))}
    imageinfo = flatdb.Holder ()
    imageinfo.naxis = img.shape.size

    if img.bmaj is None:
        warn ('no restoring beam information; will NOT deconvolve')
        imageinfo.bmaj = imageinfo.bmin = imageinfo.bpa = None
        sfinfo['deconvolved'] = 'false'
    else:
        imageinfo.bmaj = img.bmaj
        imageinfo.bmin = img.bmin
        imageinfo.bpa = img.bpa
        sfinfo['deconvolved'] = 'true'

    # Get image into MIRIAD format, possibly via FITS, run SFIND, and
    # process. We're going to change directories so canonicalize the
    # input path.

    from tempfile import mkdtemp
    from os.path import join, realpath
    from os import getcwd, chdir, devnull
    from shutil import rmtree
    import subprocess
    from mirexec import TaskFits, TaskSFind

    origdir = getcwd ()
    inpath = realpath (inpath)
    tmpcontainer = mkdtemp (prefix='sfextract.')

    try:
        mirpath = fitspath = None

        if isinstance (img, astimage.MIRIADImage):
            mirpath = inpath
        elif isinstance (img, astimage.FITSImage):
            fitspath = inpath
        else:
            fitspath = join (tmpcontainer, 'input.fits')
            img.saveAsFITS (fitspath)

        chdir (tmpcontainer)

        if mirpath is None:
            mirpath = 'input.mirimg'
            TaskFits (in_=fitspath, out=mirpath, op='xyin').runsilent ()

        stdout, stderr = TaskSFind (in_=mirpath, **keywords).snarf ()

        for l in stdout:
            if l.startswith ('FDR selected a'):
                sfinfo['pvalue'] = fortfloat (l.split ()[-1][:-1])
            if l.startswith ('This corresponds to'):
                sfinfo['sigmathresh'] = fortfloat (l.split ()[-2])
            if l.startswith ('which means a minimum'):
                sfinfo['minflux'] = fortfloat (l.split ()[-2])
            if l.startswith ('FDR detected'):
                sfinfo['npix'] = int (l.split ()[-2])
            if l.startswith ('Of the FDR pixels'):
                sfinfo['nused'] = int (l.split ()[-6])
            if l.startswith ('A total of'):
                sfinfo['nrawsrc'] = int (l.split ()[3])
            if l.startswith ('No FDR pixels'):
                npv = fortfloat (l.split ()[6])
                sfinfo['neededpvalue'] = npv
                if ss_erfinv is not None and np.isfinite (npv):
                    sfinfo['neededsigma'] = np.sqrt (2) * ss_erfinv (1 - 2 * npv)
            if l.startswith ('RMS of the interior RMS'):
                sfinfo['typrms'] = fortfloat (l.split ()[6])

        parse_and_print (sfinfo, imageinfo, open ('sfind.log'))
    finally:
        chdir (origdir)
        try:
            rmtree (tmpcontainer)
        except:
            warn ('couldn\'t remove temporary data directory "%s"', tmpcontainer)


def parse_and_print (sfinfo, iminfo, sfstream):
    import sys

    headers = ['%s=%s' % (k, sfinfo[k])
               for k in sorted (sfinfo.iterkeys ())]

    if iminfo.bmaj is None:
        gen = srctable.parseSFind (sfstream)
    else:
        def func ():
            for s in srctable.parseSFind (sfstream):
                s.pkflux = None
                srctable.deconvolve (s, iminfo.bmaj, iminfo.bmin, iminfo.bpa)
                yield s
        gen = func ()

    cols = [c for c in srctable.sfindcols
            if c.name not in ('pkflux', 'pkflux_uc')]
    flatdb.writeStreamedTable (sys.stdout.write, headers, cols, gen)


def fortfloat (s):
    if s[0] == '*':
        return np.nan
    return float (s)


def warn (fmt, args):
    print >>sys.stderr, 'warning:', fmt % args


if __name__ == '__main__':
    try:
        import mirtask.cliutil
    except ImportError:
        pass
    cmdline (sys.argv)
