#! /usr/bin/env casa-python
# -*- python -*-
# Copyright 2012 Peter Williams
# Licensed under the GNU General Public License version 3 or higher

"""
msphotom vis=<MS> [keywords...]

Extract photometry from the visibilities in a measurement set. See
below the keyword docs for some important caveats.

vis=
  Path of the MeasurementSet dataset to read. Required.

out=
  Path to which data will be written. If unspecified, data are written
  to standard output.

datacol=
  Name of the column to use for visibility data. Defaults to 'data'.
  You might want it to be 'corrected_data'.

believesigmas=[t|f]
  Defaults to false, which means that we assume that the 'sigma'
  column in the dataset isn't scaled correctly. Instead uncertainties
  are assessed from the scatter of all the visibilities in each
  timeslot. If true, sigmas are used and propagated in the standard
  way.

IMPORTANT: assumes that there's a point source at phase center, and
that all other emission has been subtracted out.

IMPORTANT: computes fluxes as (RR+LL)/2, and discards data for which
one or both of these products is missing.

IMPORTANT: doesn't do any filtering of the visbilities (i.e., no field
selection).

Prints out

  MJD dt[min] re reErr im imErr mag magErr npts

with sorted MJDs, one record for each timestamp present in the dataset,
with all fluxes in ujy. dt is simply (MJD - MJD[0])/86400.

You will probably want to apply a moving smoothing window to the
output of this program. The function smooth() in the source shows how
to do this. Recommended to plot re(t) and im(t) in the same plot
window since im(t) should give a sense of the random variation in the
data.
"""

import sys, os.path, casac, numpy as np
from kwargv import ParseKeywords, Custom

## quickutil: usage die
#- snippet: usage.py (2012 Oct 01)
#- SHA1: ac032a5db2efb5508569c4d5ba6eeb3bba19a7ca
def showusage (docstring, short, stream, exitcode):
    if stream is None:
        from sys import stdout as stream
    if not short:
        print >>stream, 'Usage:', docstring.strip ()
    else:
        intext = False
        for l in docstring.splitlines ():
            if intext:
                if not len (l):
                    break
                print >>stream, l
            elif len (l):
                intext = True
                print >>stream, 'Usage:', l
        print >>stream, \
            '\nRun with a sole argument --help for more detailed usage information.'
    raise SystemExit (exitcode)

def checkusage (docstring, argv=None, usageifnoargs=False):
    if argv is None:
        from sys import argv
    if len (argv) == 1 and usageifnoargs:
        showusage (docstring, True, None, 0)
    if len (argv) == 2 and argv[1] in ('-h', '--help'):
        showusage (docstring, False, None, 0)

def wrongusage (docstring, *rest):
    import sys
    intext = False

    if len (rest) == 0:
        detail = 'invalid command-line arguments'
    elif len (rest) == 1:
        detail = rest[0]
    else:
        detail = rest[0] % tuple (rest[1:])

    print >>sys.stderr, 'error:', detail, '\n' # extra NL
    showusage (docstring, True, sys.stderr, 1)
#- snippet: die.py (2012 Oct 01)
#- SHA1: 3bdd3282e52403d2dec99d72680cb7bc95c99843
def die (fmt, *args):
    if not len (args):
        raise SystemExit ('error: ' + str (fmt))
    raise SystemExit ('error: ' + (fmt % args))
## end

class Config (ParseKeywords):
    vis = Custom (str, required=True)
    datacol = 'data'
    believesigmas = False

    @Custom (str, uiname='out')
    def outstream (val):
        if val is None:
            return sys.stdout
        try:
            return open (val, 'w')
        except Exception as e:
            die ('cannot open path "%s" for writing', val)

RR = 5
LL = 8

def process (cfg):
    if hasattr (casac, 'homefinder'): # CASA < 4.0.0?
        tb = casac.homefinder.find_home_by_name ('tableHome').create ()
        ms = casac.homefinder.find_home_by_name ('msHome').create ()
    else:
        tb = casac.casac.table ()
        ms = casac.casac.ms ()

    # Load info we need to decode polarization stuff

    tb.open (os.path.join (cfg.vis, 'DATA_DESCRIPTION'))
    ddid_to_pid = tb.getcol ('POLARIZATION_ID')
    tb.close ()

    tb.open (os.path.join (cfg.vis, 'POLARIZATION'))
    numcorrs = tb.getcol ('NUM_CORR')
    npids = numcorrs.size
    prodinfo = [None] * npids

    for i in xrange (npids):
        corrtypes = tb.getcell ('CORR_TYPE', i)
        rridx = llidx = None

        for j in xrange (numcorrs[i]):
            if corrtypes[j] == RR:
                rridx = j
            elif corrtypes[j] == LL:
                llidx = j

        if rridx is not None and llidx is not None:
            prodinfo[i] = (rridx, llidx)

    tb.close ()

    ddprods = [prodinfo[p] for p in ddid_to_pid]

    # Now we can read the visibilities. The sigma values don't seem to
    # have their absolute scale set correctly but we can still use
    # them to set the relative weighting of the data points.

    ms.open (cfg.vis)
    ms.iterinit ()
    ms.iterorigin ()
    colnames = [cfg.datacol] + 'flag sigma time data_desc_id'.split ()
    tbins = {}

    while True:
        cols = ms.getdata (items=colnames)

        for i in xrange (cols['time'].size):
            data = cols[cfg.datacol][:,0,i]
            flags = cols['flag'][:,0,i]
            sigma = cols['sigma'][:,i]
            time = cols['time'][i]

            prodinfo = ddprods[cols['data_desc_id'][i]]
            if prodinfo is None:
                continue # this record doesn't contain both RR and LL

            rr, ll = prodinfo
            if flags[rr] or flags[ll]:
                continue

            d = 0.5 * (data[rr] + data[ll])
            wt = 4. / (sigma[rr]**2 + sigma[ll]**2)
            wd = wt * d
            wd2 = wt * (d.real**2 + (1j) * d.imag**2)

            tdata = tbins.get (time, None)
            if tdata is None:
                tbins[time] = [wd, wd2, wt, wt**2, 1]
            else:
                tdata[0] += wd
                tdata[1] += wd2
                tdata[2] += wt
                tdata[3] += wt**2
                tdata[4] += 1

        if not ms.iternext ():
            break

    ms.close ()

    # Could gain some efficiency by using a better data structure than a dict().
    st = sorted (tbins.iterkeys ())

    for t in st:
        wd, wd2, wt, wt2, n = tbins[t]

        mjd = t / 86400.
        dtmin = (t - st[0]) / 60.
        r_ujy = wd.real / wt * 1e6 # -> uJy
        i_ujy = wd.imag / wt * 1e6
        r2_ujy = wd2.real / wt * 1e12
        i2_ujy = wd2.imag / wt * 1e12

        if cfg.believesigmas:
            ru_ujy = wt**-0.5 * 1e6
            iu_ujy = wt**-0.5 * 1e6
        else:
            rv_ujy = r2_ujy - r_ujy**2 # variance among real/imag msmts
            iv_ujy = i2_ujy - i_ujy**2
            ru_ujy = np.sqrt (rv_ujy * wt2) / wt # uncert in mean real/img values
            iu_ujy = np.sqrt (iv_ujy * wt2) / wt

        mag = np.sqrt (r_ujy**2 + i_ujy**2)
        umag = np.sqrt (r_ujy**2 * ru_ujy**2 + i_ujy**2 * iu_ujy**2) / mag

        print >>cfg.outstream, \
            '%12.5f %6.2f %10.2f %10.2f %10.2f %10.2f %10.2f %10.2f %d' % \
            (mjd, dtmin, r_ujy, ru_ujy, i_ujy, iu_ujy, mag, umag, n)


def smooth (re, reerr, im, imerr, window):
    """Sample function for reference. Not used in this task."""
    conv = lambda q, r: np.convolve (q, r, mode='valid')

    rewt = reerr**-2
    cre = conv (rewt * re, window) / conv (rewt, window)
    crerr = np.sqrt (conv (rewt, window**2)) / conv (rewt, window)

    imwt = imerr**-2
    cim = conv (imwt * im, window) / conv (imwt, window)
    cimrr = np.sqrt (conv (imwt, window**2)) / conv (imwt, window)

    return cre, crerr, cim, cimerr


def cmdline (argv):
    checkusage (__doc__, usageifnoargs=True)
    cfg = Config ().parse (argv[1:])
    process (cfg)


if __name__ == '__main__':
    cmdline (sys.argv)
