#!/usr/bin/env ruby
	
require 'miriad' # David M's miriad tools
require 'fx/conf'

=begin
	The main goal of this class takes the SEFD output file from Karto's program "newcalcal"
	or its descendant and updates a miriad file to contain the correct
	tsys values. It is broken up into static methods that might possibly be useful
	in other contexts.
=end

class SEFD
	# class constants (Ruby has retarded class variables that we
	# are all cautioned not to use!)
	def self.JYPK
		return 163.0
	end


	#
	# Flag as "bad" all antennas that have Tsys lower than a threshold value
	#
	def self.flagBadAntennas(tsys_table, max_tsys, miriad_path)

		# Generate comma delimited lists of bad antennas and tsys values
		# Notice the fortran-style indexing of antenna numbers!
		bad_ants = ""
		nants = tsys_table.length
		for i in (1..nants)
			if tsys_table[i-1] > max_tsys then # c-style indexing in tsys_table
				bad_ants += i.to_s
				if (i != nants) then 
					bad_ants += ","
				end
			else
				puts i.to_s + ", " + (tsys_table[i-1] * self.JYPK).to_s + " is good"
			end
		end
		# flag band antennas
		cmd = "uvflag vis=" + miriad_path + " flagval=flag select=\"ant(" + bad_ants + ")\""
		puts cmd
		system (cmd)

		exit

	end # flagBadAntennas

	#
	# Overwrite tsys table in new miriad file. The path/name of the new
	# file is returned.
	#
	def self.applyTsysTable(tsys_table, miriad_path)

		newfile = miriad_path + "_tsys"
		cmd = "uvputhd vis=" + miriad_path + " out=" + newfile + " hdvar=systemp varval="

		# Notice the fortran-style indexing of antenna numbers!
		nants = tsys_table.length
		for i in (1..nants)
			cmd += tsys_table[i-1].to_s # c-style indexing in tsys_table
			if (i != nants) then
				cmd += ","
			end
		end

		
		puts cmd
		system(cmd)

		return newfile

	end # applyTsysTable

	#
	# Read the sytem temperatures for all available antennas and polarizations
	# out of the "sefd" file that is generated by Karto's newcalcal routine
	# or its descendent.
	#
	def self.ReadSEFD(sefd_path=nil, max_tsys = 100.0)
		# read args from command line
		if sefd_path == nil 
			puts "Usage: read_sefd.rb <full sefd path/file> [max_tsys default=100K]" 
			exit
		end
		sefd_path = sefd_path + "/sefd"
	
		# check value of tsys
		if  max_tsys <= 0.0 then
			puts "max_tsys value " + max_tsys.to_s + " must be strictly positive."
			exit
		end

		# Discover how many antennas are in the array
		# (FXConf.antpos returns an N+1 array of three
		# element arrays. (The +1 is for a dummy entry
		# at index 0, i.e. the first element, so that
		# MIRIAD's 1-based antenna numbers can be used
		# as indices.)
		antpos = FXConf.antpos
		nants = antpos.length - 1

		# discover how many antennas are in the array
=begin		nants = 0
		antpos = FXConf.antpos_file.chomp()
		antpos_array = antpos.split(/\n/)
		antpos_array.each do |line|
			if line[0,1] != "#" then
				nants += 1
			end
		end
=end
		
		# make arrays to hold all results, intitialized to very high value
		# means that such antennas won't contribute to final image
		obviously_bad_tsys = 10000000.0
		x_ant_tsys = Array.new(nants, obviously_bad_tsys)
		y_ant_tsys = Array.new(nants, obviously_bad_tsys)
		tsys_vals = [x_ant_tsys, y_ant_tsys]
		
		# Read data from sefd file
		sefd_file = File.open(sefd_path, "r")
		
		# discard first two lines
		line = sefd_file.gets
		line = sefd_file.gets
		
		while (line = sefd_file.gets)
			string_array = line.split(/\s+/)
			ant = string_array[1].to_i
			pol = string_array[2]
			ts = string_array[7].to_f / self.JYPK
			# Notice that antennas are numbered fortran-style, starting from 1
			# the first antenna is placed in array index zero
			if ts < max_tsys then
				if pol["x"] then
					x_ant_tsys[ant-1] = ts.to_f
				elsif pol["y"] 
					y_ant_tsys[ant-1] = ts.to_f
				end
			end
		end


	# return two arrays, one for x and one for y
	return tsys_vals

	end # ReadSEFD

end # end of class	

#
# main program
# Takes input arguemnts and corrects a single-polarization miriad file for system temperatures.
#
	# read args from command line
	if ARGV.length != 3
		puts "Usage: single_pol_tsys_flag.rb <full sefd path/file> miriad_file max_tsys_retained" 
		exit
	end
	sefd_path = ARGV[0]
	miriad_path = ARGV[1]
	max_tsys = ARGV[2].to_f
	#puts "Arguments " + sefd_path + ", " + miriad_path + ", " + max_tsys.to_s

	# get tsys values from SEFD file
	tsys_vals = SEFD.ReadSEFD(sefd_path, max_tsys)


# for checking the output
=begin
	for i in 0..(tsys_vals[0].length-1) do
		puts i.to_s + " x, " + tsys_vals[0][i].to_s
	end
	for i in 0..(tsys_vals[1].length-1) do
		puts i.to_s + " y, " + tsys_vals[1][i].to_s
	end
=end	


	# are we correcting xx or yy miriad file?
	single_pol_tsys = nil
	if miriad_path["xx"] then 
		single_pol_tsys = tsys_vals[0]
	elsif miriad_path["yy"] then
		single_pol_tsys = tsys_vals[1]
	else
		puts "Miriad file " + miriad_path + " is not recognizable as xx or yy pol file."
		exit
	end

	# apply the tsys table to the miriad file
	new_miriad_path = SEFD.applyTsysTable(single_pol_tsys, miriad_path)

	# flag the bad antennas, according to specified max_tsys value
	SEFD.flagBadAntennas(single_pol_tsys, max_tsys, new_miriad_path)

	exit
# end of main program

