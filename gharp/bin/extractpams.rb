#!/usr/bin/env ruby
	
require 'fx/conf'

=begin (this is how you begin / end a comment block)
	Extract the SEFD data from a bunch of files taken with different PAM settings 
	and different frequencies, and write them out to one file that has all the required info
	in a nice order for plotting.
=end

class SEFD

	# Here is an example of a class variable: N.B.
	# class constants (Ruby has retarded class variables that we
	# are all cautioned not to use!)
	def self.JYPK
		return 163.0 
	end

	#
	# Read the sytem temperatures for all available antennas and polarizations
	# out of the "sefd" file that is generated by Karto's newcalcal routine
	# or its descendent.
	# NOTE THIS VERSION DIVERGES FROM THE ReadSEFD IN APPLYSEFD.RB!
	#
	def self.ReadSEFD(sefd_path=nil)
		# read args from command line
		if sefd_path == nil 
			puts "Usage: read_sefd.rb <full sefd path/file> " 
			exit
		end
		sefd_path = sefd_path + "/sefd"
	
		# Discover how many antennas are in the array
		# (FXConf.antpos returns an N+1 array of three
		# element arrays. (The +1 is for a dummy entry
		# at index 0, i.e. the first element, so that
		# MIRIAD's 1-based antenna numbers can be used
		# as indices.)
		antpos = FXConf.antpos
		nants = antpos.length - 1

		# make arrays to hold all results, intitialized to very high value
		# means that such antennas won't contribute to final image
		obviously_bad_tsys = 10000000.0
		x_ant_tsys = Array.new(nants, obviously_bad_tsys)
		y_ant_tsys = Array.new(nants, obviously_bad_tsys)
		tsys_vals = [x_ant_tsys, y_ant_tsys]
		
		# Read data from sefd file
		sefd_file = File.open(sefd_path, "r")
		
		# discard first two lines
		line = sefd_file.gets
		line = sefd_file.gets
		
		while (line = sefd_file.gets)
			string_array = line.split(/\s+/)
			ant = string_array[1].to_i
			pol = string_array[2]
			ts = string_array[7].to_f / self.JYPK
			# Notice that antennas are numbered fortran-style, starting from 1
			# the first antenna is placed in array index zero
			if pol["x"] then
				x_ant_tsys[ant-1] = ts.to_f
			elsif pol["y"]
				y_ant_tsys[ant-1] = ts.to_f
			end
		end


	# return two arrays, one for x and one for y
	return tsys_vals

	end # ReadSEFD

end # end of class	

#
# main program
# Takes input arguemnts and corrects a single-polarization miriad file for system temperatures.
#
	# read args from command line
	if ARGV.length < 1
		puts "Usage: programname freq" 
		exit
	end
	freq = ARGV[0]
	puts "Arguments: " + freq


	# use commmand line arguments to get a listing of all the sefd files
	files = Dir.glob("cal*" + freq + "*")

	# this array holds the tsys values temporarily
	tsys_arrays = [files.length]

	# read in all the tsys files
	for i in 0..(files.length-1) do
		sefd_path = files[i]

		# get tsys values from SEFD file
		tsys_vals = SEFD.ReadSEFD(sefd_path)
		tsys_arrays[i] = tsys_vals

=begin          # take out comments (=begin/=end) to see the output
		# print the output of reading sefd file
		for i in 0..(tsys_vals[0].length-1) do
			puts i.to_s + " x, " + tsys_vals[0][i].to_s
		end
		for i in 0..(tsys_vals[1].length-1) do
			puts i.to_s + " y, " + tsys_vals[1][i].to_s
		end
=end

	end

	# we have all the data read in 
	# now write out a wide ascii file with the tsys values from all antennas in order
	output_file = File.open("PAMs" + freq + ".dat", "w")

	# write file header
	output_file.puts "Frequency " + freq 
	header = "\t"

	# x's followed by y's (tab delimited)
	for i in 0..(tsys_arrays[0][0].length-1) do
		header = header + (i+1).to_s + "x \t" + (i+1).to_s + "y \t"
	end
	
	# send header to file
	output_file.puts header
	
	# write tsys values for each antenna / pol
	# for each sefd file
	for i in 0..(tsys_arrays.length-1) do
		# write filename
		str_arr = files[i].split(".")
		pam_value = str_arr[str_arr.length - 1]
		line = pam_value + "\t"

		tsys_vals = tsys_arrays[i]
		for j in 0..(tsys_vals[0].length-1) do
			# write next tsys value
			line = line + tsys_vals[0][j].to_s + "\t"
			line = line + tsys_vals[1][j].to_s + "\t"
		end

		# write row of tsys values to file
		output_file.puts line
	end

	output_file.close


exit # end of main program

