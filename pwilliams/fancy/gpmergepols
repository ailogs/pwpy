#! /usr/bin/env python
# -*- python -*-

"""= gpmergepols - merge gains tables for multi-pol data
& pkgw
: calibration
+
 The tasks SELFCAL and MSELFCAL only operate on data of a single 
 polarization at a time. GPMERGEPOLS will take separate 
 single-feed two gains solutions, such as those created by
 running SELFCAL on data split into XX and YY pols, and
 merge them together into one table that can be applied to
 multiple-polarization datasets.

 GPMERGEPOLS is fairly strict in ensuring that its inputs have 
 gains tables for the same number of antennas, the same times, and
 so on.

< vis
 Two input datasets. The first should contain a solution for the 
 X or L feeds only and the second should contain a solution for the
 Y or R feeds only.

< out
 The name of an output dataset. The created dataset will contain the
 gain information but no visibility data. The gains in this set can
 by copied to visibility datasets with GPCOPY.

< ttol
 The tolerance for differing gain solution timestamps in the datasets,
 measured in seconds. If SELFCAL is run separately on the XX and YY
 pols in a dataset, the gain solution timestamps will vary slightly
 between the two gains solutions. Default is 1 second, which should
 be strict but not overly so.
--
"""

import sys, miriad
import numpy as N
from mirtask import keys, readgains
from mirtask.util import printBannerSvn

SVNID = '$Id$'
banner = printBannerSvn ('gpmergepols', 'merge gains table for multi-pol data',
                         SVNID)

# Args

keys.keyword ('vis', 'f', ' ', 2)
keys.keyword ('out', 'f', ' ')
keys.keyword ('ttol', 'd', 1.0)
opts = keys.process ()

if len (opts.vis) != 2:
    print >>sys.stderr, 'Error: must specify two input vis or gains files'
    sys.exit (1)

if opts.out == ' ':
    print >>sys.stderr, 'Error: must specify an output dataset'
    sys.exit (1)

ttol = opts.ttol / 86400


# Read in gains, check consistency

ds1 = miriad.Data (opts.vis[0]).open ('rw')
int1 = ds1.getHeaderDouble ('interval', 0)
gr1 = readgains.GainsReader (ds1)
gr1.prep ()

ds2 = miriad.Data (opts.vis[1]).open ('rw')
int2 = ds1.getHeaderDouble ('interval', 0)
gr2 = readgains.GainsReader (ds2)
gr2.prep ()

for (gr, dset) in ((gr1, opts.vis[0]), (gr2, opts.vis[1])):
    if gr.nfeeds != 1:
        print >>sys.stderr, 'Error: dataset %s has gains for %d feeds; expected 1' % \
            (dset, gr.nfeeds)
        sys.exit (1)

    if gr.ntau != 0:
        print >>sys.stderr, 'Error: delay terms are not supported in dataset %s' % \
            (dset, )
        sys.exit (1)

def checksame (v1, v2, msg):
    if v1 == v2:
        return

    print >>sys.stderr, 'Error: %s: %d and %d' % (msg, v1, v2)
    sys.exit (1)

checksame (gr1.nants, gr2.nants, 'disagreeing number of antennas')
checksame (gr1.nsols, gr2.nsols, 'disagreeing number of gain solutions')
checksame (int1, int2, 'disagreeing solution durations')

nants = gr1.nants


# Create and populate the new gains dataset

out = miriad.Data (opts.out)
outhnd = out.open ('c')

ds1.copyHeader (outhnd, 'history')
outhnd.openHistory ()
outhnd.writeHistory (banner)
outhnd.logInvocation ('GPMERGEPOLS')

outhnd.writeHeaderInt ('nsols', gr1.nsols)
outhnd.writeHeaderInt ('nfeeds', 2)
outhnd.writeHeaderInt ('ntau', 0)
outhnd.writeHeaderInt ('ngains', nants * 2)
outhnd.writeHeaderDouble ('interval', int1)

gout = outhnd.getItem ('gains', 'w')
gbuf = N.empty (nants * 2, dtype=N.complex64)
gen1 = gr1.readSeq ()
gen2 = gr2.readSeq ()
offset = 8

while True:
    try:
        done1 = False
        t1, g1 = gen1.next ()
    except StopIteration:
        done1 = True

    try:
        done2 = False
        t2, g2 = gen2.next ()
    except StopIteration:
        done2 = True

    if done1 or done2:
        if not (done1 and done2):
            print >>sys.stderr, 'Error: unequal number of gains solutions'
            sys.exit (1)
        break

    if abs (t1 - t2) > ttol:
        print >>sys.stderr, 'Error: disagreeing timestamps', t1, 'and', t2, \
            '(%f, tol %f)' % (t1 - t2, ttol)
        sys.exit (1)

    gbuf[0::2] = g1
    gbuf[1::2] = g2

    gout.writeDoubles (t1, offset, 1)
    offset += 8
    gout.writeComplex (gbuf, offset, 2 * nants)
    offset += 8 * 2 * nants

del gout
outhnd.closeHistory ()
outhnd.close ()
ds1.close ()
ds2.close ()


# All done
sys.exit (0)
