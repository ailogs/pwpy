#! /usr/bin/env python
# -*- python -*-

"""= uvasimg - Render UV data as an image
& pkgw
: UV analysis
+
 UVASIMG renders UV data as an image to the DS9 image viewer. When run,
 it opens a small control window that allows you to display the complex
 data in different ways (amplitude, phase, real part, imaginary part)

< vis

@ options
 Multiple options can be specified, separated by commas. Minimum-match
 is used.

 'accuma' Magic!
--
"""

import sys
import numpy as N
from mirtask import keys, uvdat
import numdisplay
import gtk
from numutils import ArrayGrower

# Make sure this works before we bother with anything else

numdisplay.open ()


# Args

keys.doUvdat ('dsl3', True)
keys.option ('accuma')
opts = keys.process ()


# Read in the data

prevn = None

for dset, pream, data, flags, n in uvdat.readAll ():
    t = pream[3]

    if prevn is None:
        prevn = n
        ag = ArrayGrower (n, dtype=data.dtype)
        accum = None
        nacc = 0
        prevt = None
        t0 = t
    else:
        if n != prevn:
            print >>sys.stderr, 'Error: changing number of channels in selected data'
            sys.exit (1)

        if t0 > t:
            print >>sys.stderr, 'Warning: time goes backwards in selected data'
        elif t0 == t and not opts.accuma:
            print >>sys.stderr, 'Warning: time repeated in selected data'

    data = data[:n]
    flags = flags[:n]

    # Could have options for what to do with this.
    data[~flags] = 0.0

    if not opts.accuma:
        ag.addLine (data)
    else:
        if prevt is None:
            accum = N.abs (data)
            nacc = N.array (flags, dtype=N.int)
        elif t == prevt:
            accum += N.abs (data)
            nacc += flags
        else:
            nacc[nacc == 0] = 1
            ag.addLine (accum / nacc)
            accum = N.abs (data)
            nacc = N.array (flags, dtype=N.int)

    prevt = t

if accum is not None and opts.accuma:
    ag.addLine (accum / nacc)

data = ag.finish ()

if data.size == 0:
    print >>sys.stderr, 'Error: no data selected'
    sys.exit (1)


# Show control window

S_LIN = 0
S_LOG = 1

class Controller (object):
    def __init__ (self, data):
        self.data = data
        self.curarray = None
        self.scale = S_LIN

        self.win = win = gtk.Window ()

        vbox = gtk.VBox ()
        self.win.add (vbox)

        def button (name, func):
            b = gtk.Button (name)
            b.connect ('clicked', func)
            vbox.pack_start (b, True, True, 4)

        button ('Amplitude', self.show_amp)
        button ('Phase', self.show_pha)
        button ('Real', self.show_real)
        button ('Imaginary', self.show_imag)
        button ('Linear', self.scale_linear)
        button ('Logarithmic', self.scale_log)
        button ('Quit', gtk.main_quit)

        win.set_title ('UV Data Visualizer')
        win.connect ('destroy', gtk.main_quit)
        win.show_all ()

        self.show_amp (None)


    def _show (self, array):
        if array is not None:
            self.curarray = array
        else:
            array = self.curarray

        if self.scale == S_LIN:
            transform = lambda x: x
            offset = 0
        else:
            transform = N.log
            offset = 1

        numdisplay.display (array, transform=transform, offset=offset)


    def show_amp (self, button):
        self._show (N.abs (self.data))

    def show_pha (self, button):
        self.scale = S_LIN
        self._show (N.arctan2 (self.data.imag, self.data.real) * 180 / N.pi)

    def show_real (self, button):
        self.scale = S_LIN
        self._show (self.data.real)

    def show_imag (self, button):
        self.scale = S_LIN
        self._show (self.data.imag)

    def scale_linear (self, button):
        self.scale = S_LIN
        self._show (None)

    def scale_log (self, button):
        self.scale = S_LOG
        self._show (None)

c = Controller (data)
gtk.main ()
