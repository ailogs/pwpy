#! /usr/bin/env python

"""
blink [-f] [-m] <image1> <image2> [...]

Cycle between two or more images in an interactive graphical
display. Each image must be of precisely the same dimensions, but the
underlying coordinate systems are ignored.

-f -- display the amplitude of the FFT of each image, rather than
  the raw values

-m -- Normalize each image by its maximum value
"""

import sys, numpy as N
from mirtask import util


def load (path, fft, maxnorm):
    import os.path, miriad
    data = None

    if os.path.exists (os.path.join (path, 'image')):
        h = miriad.ImData (path).open ('rw')
        data = h.readPlane (axes=[], topIsZero=True)
        h.close ()
    elif os.path.exists (os.path.join (path, 'table.dat')):
        import pyrap.tables
        t = pyrap.tables.table (path, ack=False)
        data = t.getcol ('map', nrow=1)[0]
        t.close ()
        data = N.squeeze (data)
        data = N.flipud (data) # same topIsZero issue as MIRIAD
        data = N.ma.MaskedArray (data)
    elif os.path.isfile (path):
        f = open (path, 'rb')
        sniff = f.read (9)
        f.close ()

        if sniff.startswith ('SIMPLE  ='):
            import pyfits
            hdulist = pyfits.open (path, mode='readonly')
            data = hdulist[0].data
            hdulist.close ()

            while data.shape[0] == 1:
                data = data[0]

            data = N.flipud (data) # same topIsZero issue as MIRIAD
            data = N.ma.MaskedArray (data)

    if data is None:
        util.die ('don\'t know what to do with file "%s"', path)

    if maxnorm:
        data /= N.ma.max (data)

    if fft:
        data = N.abs (N.fft.ifftshift (N.fft.fft2 (N.fft.fftshift (data.filled (0)))))
        data = N.ma.MaskedArray (data)

    return data


def blink (paths, fft, maxnorm):
    import ndshow

    images = [load (p, fft, maxnorm) for p in paths]

    # If a mask is "nomask", we can't do straightforward or'ing of
    # masks, so this is more complicated than you might expect.

    jointmask = N.ma.nomask

    for i in xrange (len (images)):
        if jointmask is N.ma.nomask:
            if images[i].mask is not N.ma.nomask:
                jointmask = images[i].mask
        else:
            N.logical_or (jointmask, images[i].mask, jointmask)

    for im in images:
        im.mask = jointmask

    ndshow.cycle (images, paths)


def cmdline (argv):
    util.checkusage (__doc__, argv, usageifnoargs=True)

    fft = '-f' in argv
    if fft:
        argv.remove ('-f')

    maxnorm = '-m' in argv
    if maxnorm:
        argv.remove ('-m')

    if len (argv) < 3:
        util.wrongusage (__doc__, 'at least two image arguments are required')

    blink (argv[1:], fft, maxnorm)


if __name__ == '__main__':
    import sys, mirtask.cliutil
    cmdline (sys.argv)
