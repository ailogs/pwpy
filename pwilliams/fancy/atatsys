#! /usr/bin/env python
# -*- python -*-

"""= atatsys - 
& pkgw
: Calibration
+
 ATATSYS ...

< vis

--
"""

import sys, omega, numpy as N
from numutils import *
from miriad import *
from mirtask import keys, util, uvdat
import fit
from scipy.stats.distributions import norm
from scipy.stats import kstest
from scipy.special import erf, erfc
from scipy.optimize import fmin_l_bfgs_b

SVNID = '$Id$'
banner = util.printBannerSvn ('atatsys', 'magic!', SVNID)

etaQ = 1
SECOND = 1. / 24 / 3600

# Iterative averaging TSys computer

class SysTemps (object):
    def __init__ (self):
        self.integData = {}

    def accumulate (self, bl, data, flags, inttime):
        times = flags * inttime
        dt = data * times

        tup = self.integData.get (bl)

        if tup is not None:
            d0, t0 = tup
            times += t0
            dt += d0

        self.integData[bl] = dt, times

    def _flatten (self):
        # Flatten out data into arrays of values we'll need

        seenAnts = set ()
        gai = GrowingArray (N.double, 7)
        gaa = GrowingArray (N.int, 2)

        for bl, (dt, times) in self.integData.iteritems ():
            w = N.where (times > 0)
            if len (w[0]) == 0: continue
            tw = times[w]
            dt = dt[w] / tw

            mreal = dt.real.mean ()
            sreal = dt.real.std ()
            mimag = dt.imag.mean ()
            simag = dt.imag.std ()
            
            gaa.add (bl[0], bl[1])
            gai.add (mreal, sreal, mimag, simag, tw.mean (), 0., 0.)
            seenAnts.add (bl[0])
            seenAnts.add (bl[1])

        gaa.doneAdding ()
        gai.doneAdding ()

        del self.integData

        self.ants = sorted (seenAnts)
        self.gaa = gaa
        self.gai = gai
        self.tsyses = gai.col (6)

        self.nbl = len (gaa)
        self.nant = len (seenAnts)
        self.idxs = xrange (0, self.nbl)

        self._flattenAnts ()

    def _flattenAnts (self):
        get = self.gaa.get
        index = self.ants.index
        
        for i in self.idxs:
            row = get (i)
            row[0] = index (row[0])
            row[1] = index (row[1])

        self.a1s = self.gaa.col (0)
        self.a2s = self.gaa.col (1)

    def _computeBLSysTemps (self, jyperk, sdf):
        # Compute per-baseline tsyses
        tsyses = self.tsyses
        get = self.gai.get
        
        for i in self.idxs:
            mreal, sreal, mimag, simag, meantime, tmp1, tmp2 = get (i)
            s = (sreal + simag) / 2

            if calibrated:
                gain = 1
            else:
                gain = args.flux / N.sqrt (mreal**2 + mimag**2)
            
            tsys = gain * s * etaQ * N.sqrt (2 * sdf * 1e9 * meantime) / jyperk

            #if tsys > 300: 
                #    print '  Crappy %d-%d: TSys = %g' % (bl[0], bl[1], tsys)
                #    print '    real: s, D, p:', sreal, Dr, pr
                #    print '    imag: s, D, p:', simag, Di, pi
                #    continue
        
            tsyses[i] = tsys

    def _reflattenFiltered (self, skipAnts):
        # prefix: o = old, n = new

        seenAnts = set ()
        nGaa = GrowingArray (N.int, 2)
        nGai = GrowingArray (N.double, 7)
        oA1s = self.a1s
        oA2s = self.a2s
        oAnts = self.ants
        ogaaGet = self.gaa.get
        ogaiGet = self.gai.get

        # Copy old data

        for i in self.idxs:
            a1, a2 = oAnts[oA1s[i]], oAnts[oA2s[i]]
            if a1 in skipAnts or a2 in skipAnts: continue

            nGai.addLine (ogaiGet (i))
            nGaa.add (a1, a2)
            seenAnts.add (a1)
            seenAnts.add (a2)

        nGaa.doneAdding ()
        nGai.doneAdding ()

        assert len (nGaa) > 0, 'Skipped all antennas!'
        
        self.ants = ants = sorted (seenAnts)
        self.nbl = len (nGaa)
        self.nant = len (seenAnts)
        self.idxs = idxs = xrange (0, self.nbl)
        self.gaa = nGaa
        self.gai = nGai
        self.a1s = nGaa.col (0)
        self.a2s = nGaa.col (1)
        self.tsyses = nGai.col (6)

        self._flattenAnts ()
    
    def _solve (self):
        # Solve for per-ant tsyses
        from numpy import sqrt, subtract, square, ndarray, zeros
        idxs = self.idxs
        a1s = self.a1s
        a2s = self.a2s
        tsyses = self.tsyses
        
        chiwork = ndarray (self.nbl)
        model = ndarray (self.nbl)
        resid = ndarray (self.nbl)

        def chisq (g):
            for i in idxs:
                chiwork[i] = g[a1s[i]] * g[a2s[i]]

            sqrt (chiwork, model)
            subtract (model, tsyses, resid)
            square (resid, chiwork)
            return chiwork.sum ()

        gradwork = ndarray (self.nant)

        def grad (g):
            gradwork.fill (0.)

            for i in idxs:
                a1, a2, tsys = a1s[i], a2s[i], tsyses[i]
                model[i] = sqrt (g[a1] * g[a2])
            
                # chi element = (sqrt(g1 g2) - t12)**2
                # d(elt)/dg1 = 2 (sqrt(g1 g2) - t12) * / 2 / sqrt(g1 g2) * g2
                #  = g2 * (1 - t1/sqrt(g1 g2))

                v = 1 - tsys / model[i]
                gradwork[a1] += v * g[a2]
                gradwork[a2] += v * g[a1]

            #print ' Grad:', gradwork
            return gradwork

        guess = zeros (self.nant)
        n = zeros (self.nant, dtype=N.int)

        for i in idxs:
            a1, a2, tsys = a1s[i], a2s[i], tsyses[i]

            guess[a1] += tsys
            guess[a2] += tsys
            n[a1] += 1
            n[a2] += 1

        guess /= n
        #print 'guess:', guess
        bounds = [(1., None)] * self.nant
        soln, chisq, info = fmin_l_bfgs_b (chisq, guess, grad, bounds=bounds, factr=1e9)
        rchisq = chisq / (self.nbl - self.nant)
        print 'RChiSq:', rchisq

        if info['warnflag'] != 0:
            print 'Noooo'
            print 'soln, chisq:', soln, chisq
            print 'info:', info
            raise Exception ('Solution failed')

        self.soln = soln
        self.rchisq = rchisq
        self.model = model
        self.resid = resid

    def _print (self):
        ants = self.ants
        tsyses = self.tsyses
        model = self.model
        soln = self.soln
        resid = self.resid
        a1s = self.a1s
        a2s = self.a2s
        
        print 'Systemp solutions:'

        col = 0
        sa = StatsAccumulator ()
        
        for i in xrange (0, self.nant):
            # Compute RMS residual for this ant
            sa.clear ()
            for j in self.idxs:
                if a1s[j] != i and a2s[j] != i: continue
                sa.add (resid[j])
            rms = sa.rms ()
            
            if col == 0: print ' ',
            if col < 3:
                print ' %3d %#6g (%#4g)' % (ants[i], soln[i], rms),
                col += 1
            else:
                print ' %3d %#6g (%#4g)' % (ants[i], soln[i], rms)
                col = 0

        # Make sure we end with a newline
        print
        print 'Worst residuals:'

        idxs = N.abs (resid).argsort ()
        col = 0

        for i in xrange (-10, 0):
            idx = idxs[i]
            bl = ('%d-%d' % (ants[a1s[idx]], ants[a2s[idx]])).rjust (6)
            
            if col == 0: print ' ',
            if col < 4:
                print '%s % #6g' % (bl, resid[idx]),
                col += 1
            else:
                print '%s % #6g' % (bl, resid[idx])
                col = 0

        # Make sure we end with a newline
        print
        
    def _show (self):
        ants = self.ants
        tsyses = self.tsyses
        model = self.model
        soln = self.soln
        a1s = self.a1s
        a2s = self.a2s
        
        for i in xrange (0, self.nant):
            x = []
            yobs = []
            ymod = []
            
            for j in self.idxs:
                if a1s[j] == i:
                    x.append (ants[a2s[j]])
                elif a2s[j] == i:
                    x.append (ants[a1s[j]])
                else: continue

                yobs.append (tsyses[j])
                ymod.append (model[j])

            # print x, yobs, ymod
            p = omega.quickXY (x, yobs, 'Observed', lines=False)
            p.addXY (x, ymod, 'Model', lines=False)
            p.addXY ((0, ants[-1]), (soln[i], soln[i]), 'TSys %d' % ants[i])
            p.setBounds (0, ants[-1], 0)
            p.showBlocking ()

    def flush (self, jyperk, sdf):
        self._flatten ()
        self._computeBLSysTemps (jyperk, sdf)

        while True:
            self._solve ()
            self._print ()
            #self._show ()
            
            badAnts = []
            for i in xrange (0, self.nant):
                if self.soln[i] > args.maxtsys:
                    print '   Bad antenna: %d has TSys %#5g > %#5g' % \
                          (self.ants[i], self.soln[i], args.maxtsys)
                    badAnts.append ((self.ants[i], self.soln[i]))

            if len (badAnts) == 0: break

            # Let's not flag too many at once here
            badAnts.sort (key = lambda t: t[1], reverse=True)    
            badAnts = [t[0] for t in badAnts[0:3]]
            
            self._reflattenFiltered (badAnts)
        
        #self._show ()

# Keywords and argument checking

keys.keyword ('interval', 'd', 5.)
keys.keyword ('flux', 'd', -1)
keys.keyword ('maxtsys', 'd', 350.)
keys.keyword ('vis', 'f', ' ')

args = keys.process ()

if args.vis == ' ':
    print >>sys.stderr, 'Error: no UV input specified.'
    sys.exit (1)

calibrated = args.flux < 0
if calibrated:
    print 'Assuming data are calibrated to Jansky units.'
else:
    print 'Assuming data are uncalibrated, using source flux %3g' % args.flux

if args.maxtsys <= 0:
    print >>sys.stderr, 'Error: invalid maximum TSys', maxtsys

vis = VisData (args.vis)

interval = args.interval / 60. / 24.
if interval <= 0:
    print >>sys.stderr, 'Error: invalid interval', interval
print 'Averaging interval: %#4g minutes' % args.interval

# Let's go!

sts = SysTemps ()
first = True
thePol = None

for inp, preamble, data, flags, nread in vis.readLowlevel (False):
    time = preamble[3]

    if first:
        first = False

        toTrack = ['nants', 'jyperk', 'inttime']        

        nants = inp.getVarFirstInt ('nants', 0)
        assert nants > 0
        nspect = inp.getVarFirstInt ('nspect', 0)
        nwide = inp.getVarFirstInt ('nwide', 0)
        assert nspect > 0 or nwide > 0
        jyperk = inp.getVarFirstFloat ('jyperk', 0.0)
        assert jyperk > 0
        inttime = inp.getVarFirstFloat ('inttime', 10.0)
        assert inttime > 0.
        
        if nspect > 0:
            sdf = inp.getVarDouble ('sdf', nspect)
            toTrack.append ('sdf')
            toTrack.append ('nspect')
        if nwide > 0:
            toTrack.append ('nwide')
        
        t = inp.makeVarTracker ()
        t.track (*toTrack)

        tmin = tmax = tprev = time

    if t.updated ():
        nants = inp.getVarInt ('nants')
        assert nants > 0
        if 'nspect' in toTrack:
            nspect = inp.getVarInt ('nspect')
        if 'nwide' in toTrack:
            nwide = inp.getVarInt ('nwide')
        assert nspect > 0 or nwide > 0
        jyperk = inp.getVarFloat ('jyperk')
        assert jyperk > 0
        inttime = inp.getVarFloat ('inttime')
        assert inttime > 0.

        if nspect > 0:
            sdf = inp.getVarDouble ('sdf', nspect)
        
    data = data[0:nread]
    flags = flags[0:nread]

    bl = util.decodeBaseline (preamble[4])

    if bl[0] == bl[1]: continue # skip autos
    
    pol = uvdat.getPol ()

    if not util.polarizationIsInten (pol): continue
    
    if thePol is None:
        thePol = pol
    else:
        if pol != thePol:
            print >>sys.stderr, 'Error: single-pol data only, sorry'
            sys.exit (1)

    if (time - tmin) > interval or (tmax - time) > interval:
        sts.flush (jyperk, sdf)
        tmin = tmax = time

    sts.accumulate (bl, data, flags, inttime)

sts.flush (jyperk, sdf)

# All done.
sys.exit (0)
