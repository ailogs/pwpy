#! /usr/bin/tcsh -f
# Calibrator Observing and Measurement Processing 
#         for Array Statistics and Status       
#
# This is going to be the cal observation program. Put simply, it will be
# awesome. Oh yes, it WILL be awesome.

set datapath = /home/obs/mmm/karto/cals
set corr = $1
set vis = $2
set times = ($3 $4)
set inst = (`echo $5 | tr ':' ' '`)
set marker = (`echo $times[1] | tr '[a-z]' '[A-Z]' | sed 's/\([0-9][0-9]\)\([A-Z][A-Z][A-Z]\)\([0-9][0-9]\):/\3 \2 \1 /'`)
set marker = (`date -d "$marker +0000" +%Y" "%m" "%d" "%H%M%S`)

set obsstats = /ataarchive/scratch/obs/compass/$corr/obsstats


# Collect some info from the data, using defaults

set listdata = `mktemp`
uvlist vis=$vis select="time($times[1],$times[2])" options=var,full >$listdata

set cal=`egrep '(^| )source *:' $listdata |sed -e 's/.*source *: *\([^ ]*\).*/\1/'`
set freq=`egrep '(^| )freq *:' $listdata |sed -e 's/.*freq *: *\([^ ]*\).*/\1/'`
set nchan=`egrep '(^| )nchan *:' $listdata |sed -e 's/.*nchan *: *\([^ ]*\).*/\1/'`
set sdf=`egrep '(^| )sdf *:' $listdata |sed -e 's/.*sdf *: *\([^ ]*\).*/\1/'`

set mfreq = `echo $freq | awk '{print int($1*1000)}'`
echo "Observation parameters: cal=$cal freq=$freq mfreq=$mfreq nchan=$nchan sdf=$sdf"
if (!($%cal && $%freq && $%nchan && $%sdf)) then
    echo COMPASS-AUTOFLAG `date`: "missing vars in dataset; see $listdata."
    exit 1
endif

rm -f $listdata


# Set up processing directory

set histview = /ataarchive/$marker[1]/$marker[2]/$marker[3]
set histview = $histview/status/compass-$marker[4]/$corr-$mfreq
mkdir -p $histview || exit 1
cd $histview || exit 1


# Copy data for processing

echo "uvaver vis=$vis select=time($times[1],$times[2]) ..." >>dataread
uvaver vis=$vis select="time($times[1],$times[2])" \
    options=relax,nocal,nopass,nopol out=caldata \
    |& tee -ia dataread

if ($status) then
    rm -rf caldata
    echo "Data read failed!" >> dataread
    echo COMPASS `date`: "couldn't copy data for analysis; giving up on this scan."
    exit 1
endif


# Flag

newrfisweep.csh vis=caldata options=autoedge \
    scans=999 subint=999 \
    |tee -ia newrfisweep.log


# Calibrate

set calvals = (`calinfo target=$cal freq=$freq options=auto`)
if ("$calvals[1]" == "FATAL") then
    rm -rf caldata
    echo COMPASS `date`: "no calibrator metadata ($cal $freq)! Giving up on this scan."
    exit 1
endif

set flux = "$calvals[1],$calvals[2],$calvals[3]"
set addflux = "$calvals[8]"
set sysflux = `echo $freq $sdf $nchan | awk '{print (4+($1/5)^2)*sqrt(0.10486/($2*$3))}'`
set check = `echo $sysflux $calvals[1] |awk '{if ($1 > $2) print 1; else print 0}'`
if ($check == 1) then
    echo "NOTICE: estimating lots of phase noise, setting limit loosely"
    set plim = 60
else
    set plim = `calc "asin($sysflux/$calvals[1])*180/pi"`
endif

newcalcal.csh vis=caldata sysflux=$sysflux addflux=$addflux \
    flux=$flux plim=$plim options=polsplit,sefd \
    |tee -ia newcalcal.log

if !(-e cal-$cal-$mfreq-maps/$cal.cm && -e cal-$cal-$mfreq-maps/sefd) then
    echo COMPASS `date`: "calibration failed! Not posting results."
    exit 1
endif


# SEFD results into DB

atasefd -i cal-$cal-$mfreq-maps/sefd,$mfreq 


# Histogram of antpols by Jy/K <=> SEFD stats.

set tmp=`mktemp -d compass.XXXXXX`
sed 1,2d cal-$cal-$mfreq-maps/sefd |tr '[a-z]' '[A-Z]' |awk '{print $1,$2,$7}' >$tmp/jypk

set llim = `awk '{print int(10*log($3)/log(10))-2}' $tmp/jypk |sort -n |head -n1`
set ulim = `echo $llim |awk '{print $1+20}'`

set idx = 1
while ($idx <= `wc -l $tmp/jypk |awk '{print $1}'`)
    set svals = (`sed -n {$idx}p $tmp/jypk`)
    set svals = (`awk '{print " "$4,$5" "}' ~/bin/ata.ant |grep " $svals[1] " |awk '{print $1}'`$svals[2] `echo $svals[3] |awk '{print int(10*log($1)/log(10))}'`)
    echo $svals >>$tmp/rar
    @ idx++
end

set idx = $llim
while ($idx <= $ulim)
    set count = `grep -c " $idx" $tmp/rar`
    set color = 2
    if ($idx < 46) set color = 7
    if ($idx < 39) set color = 3
    echo $idx $count $color >>$tmp/jypk2
    @ idx++
end
echo lim `echo $llim | awk '{print $1-.5,$1+20.5}'` 0  `sort -rnk2 $tmp/jypk2 |head -n1 |awk '{print $2+1}'` >$tmp/jypkstat.wip
echo "data $tmp/jypk2" >>$tmp/jypkstat.wip
sed -e 1d $datapath/wip.jypk >>$tmp/jypkstat.wip
echo "color 0" >>$tmp/jypkstat.wip

set idx = 1
set badants

while ($idx <= `wc -l $tmp/rar |awk '{print $1}'`)
    set antvals = (`sed -n {$idx}p $tmp/rar |awk '{print $1,$2-.45}'`)
    set antvals = ($antvals[1] $antvals[2] `grep -c "move $antvals[2] " $tmp/jypkstat.wip |awk '{print $1+.1}'`)
    if (`echo $antvals[2] |awk '{print int($1)}'` < $ulim) then
	echo "move $antvals[2] $antvals[3]" >>$tmp/jypkstat.wip
	echo "label $antvals[1]" >>$tmp/jypkstat.wip
    else
	set badants = $badants","$antvals[1]
    endif
    @ idx ++
end

set badants2 = (`grep "have no gains solutions." cal-$cal-$mfreq-maps/calrpt |awk '{print $2}' |tr ',' ' '`)

foreach badant2 ($badants2)
    set svals = (`echo $badant2 | sed 's/\([A-Z]\)/ \1/'`)
    set svals = (`awk '{print " "$4,$5" "}' ~/bin/ata.ant |grep " $svals[1] " |awk '{print $1}'`$svals[2])
    set badants = $badants","$svals
end

set val = `sort -rnk2 $tmp/jypk2 |head -n1 |awk '{print $2+.5}'`
cat >>$tmp/jypkstat.wip <<EOF
color 1
move $llim $val
label Bad Antennas: `echo $badants | sed 's/,//'`
mtext t 2 1 .75 `date`
end
EOF

wip $tmp/jypkstat.wip -d jypkstat-$corr.png/png </dev/null >/dev/null


# Map the field

set arc = `echo 4500 |awk '{print int($1*1.430/freq)}' freq=$freq`
set imstats = (`imstat in=cal-$cal-$mfreq-maps/$cal.rs |awk '{if (check == 1) print $0; else if ($1 == "Total") check = 1}' |sed 's/\([0-9][0-9]\)-/\1 -/g'`)
set imstats2 = (`imstat in=cal-$cal-$mfreq-maps/$cal.cm region=relcen,arcsec,"box(-$arc,-$arc,$arc,$arc)" | awk '{if (check == 1) print $0; else if ($1 == "Total") check = 1}' |sed 's/\([0-9][0-9]\)-/\1 -/g'`)
set range = `echo $imstats[3] $imstats2[4] |awk '{print $2/$1}'`
set plotscale = `echo $range | awk '{if ($1 > 500) print "log"; else print "lin"}'`
set levs = (`echo $imstats[3] $imstats2[4] |awk '{lim = 4*$1; while (lim < $2) {print lim; lim=2*lim}}'`)
set levs = `echo $levs |tr ' ' ','`
set alevel = `echo $imstats[3] $imstats2[5] |awk '{print (($2/$1)^2)^.5}'`

cgdisp in=cal-$cal-$mfreq-maps/$cal.cm,cal-$cal-$mfreq-maps/$cal.cm \
    region=relcenter,arcsec,box"(-$arc,-$arc,$arc,$arc)" \
    device=cal-$corr.png/png \
    labtyp=arcmin options=beambl,wedge,3value,mirr,full \
    csize=0.6,1 olay=cal-$cal-$mfreq-maps/$cal.olay \
    type=contour,pix levs1=$levs \
    range=0,0,$plotscale,3 >/dev/null

cat <<EOF >mapcommand.txt
cgdisp in=cal-$cal-$mfreq-maps/$cal.cm,cal-$cal-$mfreq-maps/$cal.cm
    region=relcenter,arcsec,box(-$arc,-$arc,$arc,$arc)
    device=cal-$corr.png/png
    labtyp=arcmin options=beambl,wedge,3value,mirr,full
    csize=0.6,1 olay=cal-$cal-$mfreq-maps/$cal.olay
    type=contour,pix levs1=$levs
    range=0,0,$plotscale,3
EOF


# Data retention statistics
#
# Get the time of the observation as a POSIX time. 2440587.5 is the POSIX epoch
# as a JD.
set obstime=`gethd in=cal-$cal-$mfreq-maps/$cal.cm/obstime |awk '{printf "%d", ($1 - 2440587.5)*86400}'`
set now = `date`
set nowsecs = `date +%s`
set retstat = (`sed 1,3d caldata/retmap | awk '{if (NR == 1) {max = $2}; if (NR != 1) {if ($2*1 !=0) cnt+=1; idx+=1; dcnt+=$2; didx+=max}} END {print 100*cnt/idx,100*dcnt/didx}'`)

echo $obstime $retstat[1] $retstat[2] $range $imstats[3] $alevel >>$obsstats

awk '{if ($1-now < 100000) print ($1-now)/3600,$2,$3,$4,1/($5+1e-12),$6}' now=$nowsecs $obsstats >$tmp/retention
echo "data $tmp/retention" >$tmp/retention.wip
sed -e 1d $datapath/wip.prsv >>$tmp/retention.wip # cut off hardcoded data file line
echo "mtext t 1.5 0 .25 $now" >> $tmp/retention.wip
echo "end" >> $tmp/retention.wip
wip $tmp/retention.wip -d prsv-$corr.png/png > /dev/null


# Hardware status map - note that this combines some status
# information from whenever the cal obs was made, and some from whenever
# this script is run.

cat $datapath/wip.hs > $tmp/hwstatus.wip
cat $datapath/wip.builds >> $tmp/hwstatus.wip
fxhealth >fxstatus
ataasciistatus -l | tr ',' ' ' | awk '{if ($1 != "") print $1,$2,($6^2+$7^2)^.5}' > $tmp/antstatus
set antlist = (`fxconf.rb sals | awk '{if ($1 == inst) print $0}' inst=$inst[2] | tr '[a-z]' '[A-Z]'`)
if ($#antlist > 1) shift antlist

set idx = 1
while ($idx <= `wc -l $datapath/wip.ants | awk '{print $1}'`)
    set wipline = (`sed -n {$idx}p $datapath/wip.ants`)
    set statusline = (`grep -i "ant$wipline[4]" $tmp/antstatus` 0 0 0)
    if (" $antlist " =~ *" $wipline[4] "*) then
	set color = 3
	if (`echo $statusline[3] |awk '{if ($1 > .5) print 1; else print 0}'`) set color = 7
	if ("$statusline[2]" != "Running") set color = 2
    else
	set color = 15
    endif
    echo "color $color" >> $tmp/hwstatus.wip
    echo "$wipline" >> $tmp/hwstatus.wip
    @ idx++
end

set idx = 1
while ($idx <= `wc -l $datapath/wip.fx | awk '{print $1}'`)
    set wipline = (`sed -n {$idx}p $datapath/wip.fx`)
    set twipline = (`echo $wipline | tr '[A-Z]' '[a-z]'`)
    set color = 3
    if ("$wipline[1]" == "plot") then
	if (`grep -c "$twipline[4].$twipline[5] is NOT alive!" fxstatus`) set color = 2
	echo "color $color" >> $tmp/hwstatus.wip
	echo "$wipline" >> $tmp/hwstatus.wip
    else
	echo "$wipline" >> $tmp/hwstatus.wip
    endif
    @ idx++
end
echo "mtext t 2 1 .75 $now" >> $tmp/hwstatus.wip
echo "end" >> $tmp/hwstatus.wip

wip $tmp/hwstatus.wip -d hardstat-$corr.png/png > /dev/null


# Upload imagery to logbook; clean up; call it a day.

foreach i (*-$corr.png)
    convert $i -depth 8 -geometry 350 ${i:r}-thumb.png
end

scp *.png logbook:/srv/www/vhosts/log/files/plots/.
rm -rf $tmp
exit 0
