#! /usr/bin/env python
# -*- python -*-
#
# Calculate az/el offsets associated with the datasets in a hex observation
# based on their embedded data.
#
# This code is heavily derived from that in mmm/davidm/gpfit.rb . I
# couldn't find an installation of the required Ruby libraries on the
# HCRO network, so I've ported the logic to Python and made changes
# to have it fit into the hexobs processing model.

import sys
import numpy as N
from miriad import *
from mirtask import util

if len (sys.argv) < 2:
    print >>sys.stderr, 'Usage: hex-lib-calcoffsets [datasets...]'
    sys.exit (1)


# Compute mean radecs and azels for each data file

coords = []

for vis in sys.argv[1:]:
    vis = VisData (vis).open ('rw')
    work = []

    while vis.scanUntilChange ('time'):
        obsra = vis.getVarDouble ('obsra')
        obsdec = vis.getVarDouble ('obsdec')

        lst = vis.getVarDouble ('lst')
        lat = vis.getVarDouble ('latitud')
        az, el = util.equToHorizon (obsra, obsdec, lst, lat)

        work.append ((obsra, obsdec, az, el, lst, lat))

    work = N.asarray (work)
    coords.append (work.mean (axis=0))


# Now compute offsets from the central pointing in absolute
# terms, not coordinate terms, i.e. multiply by cos (dec) or
# cos (el)

f = lambda x: '%.8f' % x

ra0, dec0 = coords[0][:2]

print 0, 0, 0, 0

for ra, dec, az, el, lst, lat in coords[1:]:
    # We compute the deltas fairly blindly. Should look up
    # the detailed computation that handles poles, etc.

    dra = (ra - ra0) * N.cos (dec0)
    ddec = dec - dec0

    # The central az/el drifts with time as the source moves
    # through the sky, so we must compute our offsets relative
    # to a changing az0/el0, not just the az/el of the central
    # pointing.

    az0, el0 = util.equToHorizon (ra0, dec0, lst, lat)
    daz = (az - az0) * N.cos (el0)
    d_el = el - el0

    print f(dra), f(ddec), f(daz), f(d_el)
