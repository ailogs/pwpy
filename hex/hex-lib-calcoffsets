#! /usr/bin/env python
# -*- python -*-
#
# Calculate az/el offsets associated with the datasets in a hex observation
# based on their embedded data.
#
# This code is heavily derived from that in mmm/davidm/gpfit.rb . I
# couldn't find an installation of the required Ruby libraries on the
# HCRO network, so I've ported the logic to Python and made changes
# to have it fit into the hexobs processing model.

import sys
import numpy as N
from miriad import *
from mirtask import util

if len (sys.argv) < 4:
    print >>sys.stderr, 'Usage: hex-lib-calcoffsets [tstart] [tend] [datasets...]'
    sys.exit (1)


# Get the time bounds we're applying. We use scanUntilChange below, which means
# we don't have access to flag information, so we can't just rely on the flagging
# of the dataset to let us know which records to pay attention to.

def tparse (s):
    if s == 'none':
        return None
    return util.dateOrTimeToJD (s)
    
tstart = tparse (sys.argv[1])
tend = tparse (sys.argv[2])


# Compute mean radecs and azels for each data file

coords = []

for vis in sys.argv[3:]:
    vis = VisData (vis).open ('rw')
    work = []

    while vis.scanUntilChange ('time'):
        time = vis.getVarDouble ('time')

        if tstart is not None and time < tstart:
            continue
        if tend is not None and time > tend:
            continue

        obsra = vis.getVarDouble ('obsra')
        obsdec = vis.getVarDouble ('obsdec')

        lst = vis.getVarDouble ('lst')
        lat = vis.getVarDouble ('latitud')
        az, el = util.equToHorizon (obsra, obsdec, lst, lat)

        work.append ((obsra, obsdec, az, el, lst, lat))

    work = N.asarray (work)
    coords.append (work.mean (axis=0))


# Now compute offsets from the central pointing in absolute
# terms, not coordinate terms, i.e. multiply by cos (dec) or
# cos (el)

f = lambda x: '%.8g' % x
wrap = lambda t: ((t + N.pi) % (2 * N.pi)) - N.pi

ra0, dec0 = coords[0][:2]

print 0, 0, 0, 0

for ra, dec, az, el, lst, lat in coords[1:]:
    # We compute the deltas fairly blindly. Should look up
    # the detailed computation that handles poles, etc.

    dra = wrap (ra - ra0) * N.cos (dec0)
    ddec = dec - dec0

    # The central az/el drifts with time as the source moves
    # through the sky, so we must compute our offsets relative
    # to a changing az0/el0, not just the az/el of the central
    # pointing.

    az0, el0 = util.equToHorizon (ra0, dec0, lst, lat)
    daz = wrap (az - az0) * N.cos (el0)
    d_el = el - el0

    print f(dra), f(ddec), f(daz), f(d_el)
