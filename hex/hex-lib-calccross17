#!/usr/bin/env ruby

# $Id$
#
# Generate cross17 pointings for a given freq, ra, and dec.  Outputs 17 ras (in
# decimal hours) followed by corresponding 17 decs (in decmial degrees).  First
# ra and first dec are center pointing; then there are 8 pointings sweeping in
# RA; then there are 8 sweeping in dec.

raise "usage: #{File.basename($0)} HMSCALE MHZ RA DEC" unless ARGV.length == 4

HWHM1 = 1.75 # HWHM in degrees at 1 GHz; assume scales as 1/freq

include Math

hmscale, freq, ra, dec = ARGV[0,4].map {|s| Float(s)}

# Convert to ghz
freq /= 1e3

# Convert hours to radians
ra = ra * PI / 12

# Convert degrees to radians
dec = dec * PI / 180
cosdec = cos(dec)
raise 'cannot do poles yet' if cosdec.abs < 1e-6

# HWHM in radians at freq
hwhm = HWHM1 * hmscale * PI / 180 / freq

# Small angle approxmations
dracross  = hwhm * 0.25 / cosdec
ddeccross = hwhm * 0.25

offsets = [
  [           0,        0],
  [	 4*dracross,	0],
  [	 3*dracross,	0],
  [	 2*dracross,	0],
  [	 1*dracross,	0],
  [	-1*dracross,	0],
  [	-2*dracross,	0],
  [	-3*dracross,	0],
  [	-4*dracross,	0],
  [	      0,   4*ddeccross],
  [	      0,   3*ddeccross],
  [	      0,   2*ddeccross],
  [	      0,   1*ddeccross],
  [	      0,  -1*ddeccross],
  [	      0,  -2*ddeccross],
  [	      0,  -3*ddeccross],
  [	      0,  -4*ddeccross],
]

radecs = offsets.map do |dra, ddec|
  radra, decddec = ra+dra, dec+ddec
  # Check for over the top
  if decddec > PI / 2
    radra += PI
    decddec = PI - decddec
  end
  [radra, decddec]
end

ras, decs = radecs.transpose

# Convert radians to hours
ras.map! {|rad| (rad * 12 / PI) % 24}

# Convert radians to degrees
decs.map! {|rad| rad * 180 / PI}

[ras, decs].flatten.each do |x|
  printf " %.6f", x
end
puts
