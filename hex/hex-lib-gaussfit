#! /usr/bin/env python
# -*- python -*-
#
# Fit two-dimensional Gaussians to the relative antpol gains, giving
# a measurement of the primary beamshape of each antenna/feed pairing.
#
# This code is heavily derived from that in mmm/davidm/gpfit.rb . I
# couldn't find an installation of the required Ruby libraries on the
# HCRO network, so I've ported the algorithm to Python and made changes
# to have it fit into the hexobs processing model.

import sys
from os.path import join
import numpy as N
from mpfit import mpfit
from miriad import *
from mirtask import util

pretty = '-p' in sys.argv
if pretty: sys.argv.remove ('-p')

if len (sys.argv) < 2:
    print >>sys.stderr, 'Usage: hex-lib-gaussfit [analysisdir] [analysisdirs...]'
    sys.exit (1)


# Load data

i = 0
ghz = None
offsets = []
gains = {}
guncerts = {}
runs = {}
runnpts = []
runofs = []

for analysisdir in sys.argv[1:]:
    sinfofn = join (analysisdir, 'data-sinfo.txt')
    ofsfn = join (analysisdir, 'data-offsets.txt')
    gainsfn = join (analysisdir, 'data-relgains.txt')
    errsfn = join (analysisdir, 'data-relgainerrs.txt')

    thisghz = None

    for l in file (sinfofn, 'r'):
        a = l.strip ().split ()

        if a[0] == 'freq':
            thisghz = float (a[1]) * 1e-3

    assert thisghz is not None

    if ghz is None:
        ghz = thisghz
    elif thisghz != ghz:
        print >>sys.stderr, 'Error: different observing frequencies for datasets!'
        sys.exit (1)

    theseoffsets = [map (float, l.strip ().split ()) for l in file (ofsfn, 'r')]
    offsets += theseoffsets

    if i == 0:
        runofs.append (0)
    else:
        runofs.append (runofs[-1] + runnpts[-1])

    thisn = len (theseoffsets)
    runnpts.append (thisn)

    for l in file (gainsfn, 'r'):
        a = l.strip ().split ()

        if len (a) != thisn + 3:
            print >>sys.stderr, 'Error: unexpected number of entries in', gainsfn, ':', \
                  len (a), 'not', thisn + 3
            sys.exit (1)

        ant = int (a[0])
        pol = a[1]
        key = (ant, pol)

        if a[2] != 'amp':
            continue

        amps = map (float, a[3:])

        if amps[0] == 0:
            continue # No gain solution for this antpol

        if key not in runs:
            runs[key] = [i]
        else:
            runs[key].append (i)

        # TODO: do something with the phases
        if key not in gains: gains[key] = []
        gains[key] += amps

    for l in file (errsfn, 'r'):
        a = l.strip ().split ()

        if len (a) != 3 + thisn:
            print >>sys.stderr, 'Error: unexpected number of entries in', gainsfn, ':', \
                  len (a), 'not', 3 + thisn
            sys.exit (1)

        ant = int (a[0])
        pol = a[1]
        ltype = a[2]

        if ltype != 'aerr':
            continue

        key = (ant, pol)

        # FIXME: can have '-' for no gain solution for a pointing
        errs = map (float, a[3:])

        # TODO: do something with the phases
        if key not in guncerts: guncerts[key] = []
        guncerts[key] += errs

    i += 1

nruns = i
offsets = N.asarray (offsets)
npts = offsets.shape[0]

if npts < 6:
    print >>sys.stderr, 'Error: need at least 6 points to run a 2D Gaussian fit, ' \
          'only have', npts
    sys.exit (1)


# The fits

_parinfo = [{'parname': 'amp',
             'limited': [True, False],
             'limits': [0., 0.],
             'value': 1.0},
            {'parname': 'x0',
             'limited': [False, False],
             'limits': [0., 0.],
             'value': 0.0},
            {'parname': 'y0',
             'limited': [False, False],
             'limits': [0., 0.],
             'value': 0.0},
            {'parname': 'xw',
             'limited': [True, False],
             'limits': [0., 0.],
             'value': 0.0},
            {'parname': 'yw',
             'limited': [True, False],
             'limits': [0., 0.],
             'value': 0.0}]
            
def fit (sigma, xs, ys, amps, errs, **kwargs):
    _parinfo[3]['value'] = sigma
    _parinfo[4]['value'] = sigma

    # FIXME: should just use fit.py but I worry that it will fall down
    # for two-dimensional 'x' coordinates.

    wts = 1 / errs

    def f (params, fjac=None):
        a, x0, y0, xw, yw = params
        model = a * N.exp (-0.5 * (((xs - x0) / xw)**2 + ((ys - y0) / yw)**2))
        return 0, wts * (amps - model)

    o = mpfit (f, parinfo=_parinfo, quiet=True, **kwargs)

    if o.status <= 0 or o.status >= 5:
        raise Exception ('MPFIT failed: %d, %s' % (o.status, o.errmsg))
    if o.perror is None:
        raise Exception ('MPFIT failed to find uncerts: %d, %s' % (o.status, o.errmsg))

    resids = f (o.params)[1]

    return o.params, o.perror, resids, o.fnorm

# TODO: fit in both RA/Dec and Az/El coordinates
xs = offsets[:,2]
ys = offsets[:,3]

hwhm = 1.75 / ghz * N.pi / 180
sigma = hwhm / N.sqrt (2 * N.log (2))

fitdata = {}
class Fit (object): pass

for ((ant, pol), gamps) in gains.iteritems ():
    f = Fit ()
    fitdata[(ant, pol)] = f

    gamps = N.asarray (gamps)
    f.amps = gamps**-2 # gain -> sensitivity
    f.gerrs = (N.asarray (guncerts[(ant, pol)]) * 2 / gamps**3)
    f.ant = ant
    f.pol = pol

    # Get the X and Y offsets for this antenna - some subset of
    # xs and ys, depending on which runs it was involved in.

    antruns = runs[(ant, pol)]
    f.nruns = len (antruns)

    if f.nruns == nruns:
        # Must be in all of them
        antxs = xs
        antys = ys
    else:
        idxarr = []

        for i in antruns:
            idxarr += range (runofs[i], runofs[i] + runnpts[i])

        idxarr = N.asarray (idxarr)
        antxs = xs[idxarr]
        antys = ys[idxarr]

    f.npts = antxs.size
    
    if f.npts < 6:
        print 'Warning: antpol %d%s has too few (%d) points to fit (need 6)' \
              % (ant, pol, f.npts)
        f.failed = True
        continue

    # Now we can do the fit.

    try:
        params, puncerts, resids, chisq = fit (hwhm, antxs, antys, f.amps, f.gerrs)
        f.failed = False
        f.params = params
        f.puncerts = puncerts
        f.resids = resids
        f.chisq = chisq
        f.rchisq = chisq / (f.amps.size - params.size)
    except Exception:
        import traceback
        traceback.print_exc ()
        print >>sys.stderr, 'The fit for antpol', ant, pol, 'failed.'
        f.failed = True


# Print out results

print >>sys.stderr, 'Modeled HWHM:', hwhm * 180 / N.pi

_conv = N.sqrt (2 * N.log (2)) * 180 / N.pi # sigma -> HWHM, rad -> deg
_scale = N.asarray ([1, 206265, 206265, _conv, _conv])

for key in sorted (fitdata.iterkeys ()):
    f = fitdata[key]

    if pretty:
        print 'Antpol', f.ant, f.pol, ':'

        if f.failed:
            print '   Failed'
            continue

        u = lambda i: '%.2f%%' % (f.puncerts[i] / N.abs (f.params[i]) * 100) # * uscale)
        vals = f.params * _scale
    
        print '   # points:', f.npts
        print '   Amp:', vals[0], '+-', u (0)
        print '   Offsets:', vals[1], 'arcsec;', vals[2], 'arcsec'
        print '      uncerts:', u (1), ';', u (2)
        print '   Widths:', vals[3], 'deg;', vals[4], 'deg'
        print '      uncerts:', u (3), ';', u (4)
        print '   --Amps:', f.amps
        print '   Resids:', f.resids
        print '   RChisq:', f.rchisq #/ uscale**2
        print
    else:
        print f.ant, f.pol, f.npts, 

        if f.failed:
            print 0
            continue

        vals = f.params * _scale
        us = f.puncerts * _scale

        print 1, f.rchisq,
        print vals[0], us[0], vals[1], us[1], vals[2], us[2], vals[3], us[3], vals[4], us[4]
